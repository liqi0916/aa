<div class="blog-content-box">
    <div class="article-header-box">
        <div class="article-header">
            <div class="article-title-box">
                <h1 class="title-article" id="articleContentId">Git常用命令详解</h1>
            </div>
            <div class="article-info-box">
                <div class="article-bar-top">
                    <!--文章类型-->
                                        <!--原创-->
                                        <img class="article-type-img" src="https://csdnimg.cn/release/phoenix/template/new_img/original.png" alt="">
                                        <!--翻译-->
                                        <!--转载-->
                                        <div class="bar-content">
                                                                                                                                            <a class="follow-nickName" href="https://me.csdn.net/weelyy" target="_blank" rel="noopener">Windy_729</a>
                    <span class="time">2018-09-23 18:13:42</span>
                    <img class="article-read-img article-heard-img" src="https://csdnimg.cn/release/phoenix/template/new_img/articleReadEyes.png" alt="">
                    <span class="read-count">27965</span>
                    <a id="blog_detail_zk_collection" class="un-collection" data-report-click="{&quot;mod&quot;:&quot;popu_823&quot;,&quot;spm&quot;:&quot;1001.2101.3001.4232&quot;,&quot;ab&quot;:&quot;new&quot;}">
                        <img class="article-collect-img article-heard-img un-collect-status" style="display:inline-block" src="https://csdnimg.cn/release/phoenix/template/new_img/tobarCollect.png" alt="">
                        <img class="article-collect-img article-heard-img collect-status" style="display:none" src="https://csdnimg.cn/release/phoenix/template/new_img/tobarCollectionActive.png" alt="">
                        <span class="name">收藏</span>
                        <span class="get-collection">
                                                136                                                </span>
                    </a>
                                        </div>
                </div>
                <div class="blog-tags-box">
                <div class="tags-box artic-tag-box">
                                           <span class="label">分类专栏：</span>
                                                                                             <a class="tag-link" target="_blank" rel="noopener" href="https://blog.csdn.net/weelyy/category_8079428.html">
                                       版本控制系统                                   </a>
                                                                                                                                   
                </div>
                </div>
                                <div class="up-time"><span>最后发布：2018-09-23 18:13:42</span><span>首次发布：2018-09-23 18:13:42</span></div>
                <div class="slide-content-box">
                <div class="all-tags-box">
                                    </div>
                                                                    <div class="article-copyright">
                            <div class="creativecommons">
                                <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"></a>
                            </div>
                            <div class="creativecommons">
                                版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                            </div>
                            <div class="article-source-link">
                                本文链接：<a href="https://blog.csdn.net/weelyy/article/details/82823798">https://blog.csdn.net/weelyy/article/details/82823798</a>
                            </div>
                        </div>
                                                                                </div>
                <div class="operating">
                                                                <a class="href-article-edit slide-toggle">版权</a>
                                    </div>
            </div>
        </div>
    </div>
    <!--python安装手册结束-->
                    <article class="baidu_pl">
                 <div id="article_content" class="article_content clearfix">
            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3d4dc5c1de.css">
                            <div id="content_views" class="markdown_views prism-atom-one-light">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                                            <hr>
<p></p><div class="toc"><h3><a name="t0"></a><a name="t0"></a>文章目录</h3><ul><ul><li><a href="#Git_3" rel="nofollow" target="_self">Git简介</a></li><li><a href="#_12" rel="nofollow" target="_self">三个区</a></li><li><a href="#_19" rel="nofollow" target="_self">主要的几个命令</a></li><li><a href="#git_commit_33" rel="nofollow" target="_self">git commit用法</a></li><li><a href="#git_stash_55" rel="nofollow" target="_self">git stash用法</a></li><li><a href="#git_reset_72" rel="nofollow" target="_self">git reset用法</a></li><li><a href="#git_reflog_93" rel="nofollow" target="_self">git reflog</a></li><li><a href="#git_add_110" rel="nofollow" target="_self">git add</a></li><li><a href="#git_checkout_119" rel="nofollow" target="_self">git checkout</a></li><ul><li><a href="#git_checkout_121" rel="nofollow" target="_self">git checkout切换分支</a></li><li><a href="#git_checkout__132" rel="nofollow" target="_self">git checkout 回退修改</a></li></ul><li><a href="#git_revert_141" rel="nofollow" target="_self">git revert</a></li><li><a href="#resetcheckoutrevert_149" rel="nofollow" target="_self">reset,checkout,revert总结</a></li><li><a href="#_162" rel="nofollow" target="_self">删除分支</a></li><li><a href="#git_push_171" rel="nofollow" target="_self">git push</a></li><li><a href="#git_pull_227" rel="nofollow" target="_self">git pull</a></li><ul><li><a href="#1_git_merge_260" rel="nofollow" target="_self">1. git merge</a></li><li><a href="#2_git_rebase_280" rel="nofollow" target="_self">2. git rebase</a></li><li><a href="#3_rebaserebase_304" rel="nofollow" target="_self">3. rebase的高级操作--交互式rebase</a></li><li><a href="#4_Rebase_345" rel="nofollow" target="_self">4. Rebase的黄金法则</a></li><li><a href="#5_rebae_357" rel="nofollow" target="_self">5. rebae的本地清理功能</a></li></ul><li><a href="#_371" rel="nofollow" target="_self">追踪关系</a></li><li><a href="#git_386" rel="nofollow" target="_self">git冲突的修复</a></li><ul><li><a href="#1__387" rel="nofollow" target="_self">1. 直接编辑冲突文件</a></li><li><a href="#2__402" rel="nofollow" target="_self">2. 利用图形界面工具解决冲突</a></li><li><a href="#3__415" rel="nofollow" target="_self">3. 代码提交完整流程</a></li></ul><li><a href="#_429" rel="nofollow" target="_self">常用命令速查表</a></li></ul></ul></div><p></p>
<h2><a name="t1"></a><a name="t1"></a><a id="Git_3"></a>Git简介</h2>
<p>Git是Linux之父Linus的第二个伟大的作品，它最早是在Linux上开发的，被用来管理Linux核心的源代码。后来慢慢地有人将其移植到了Unix、Windows、Max OS等操作系统中。</p>
<p>Git是一个分布式的版本控制系统，与集中式的版本控制系统不同的是，每个人都工作在通过克隆建立的本地版本库中。也就是说每个人都拥有一个完整的版本库，查看提交日志、提交、创建里程碑和分支、合并分支、回退等所有操作都直接在本地完成而不需要网络连接。</p>
<p>对于Git仓库来说，每个人都有一个独立完整的仓库，所谓的远程仓库或是服务器仓库其实也是一个仓库，只不过这台主机24小时运行，它是一个稳定的仓库，供他人克隆、推送，也从服务器仓库中拉取别人的提交。</p>
<p>Git是目前世界上最先进的分布式版本控制系统，没有之一，对，没有之一!</p>
<h2><a name="t2"></a><a name="t2"></a><a id="_12"></a>三个区</h2>
<p><img src="http://static.zybuluo.com/Wind729/y4ufbhzizn3a7xfbbjibdbig/git_three_rigon.png" alt="git_three_rigon.png-212.9kB"></p>
<p>工作区(working diretory)   用于修改文件<br>
缓存区(stage)   是用来暂时存放工作区中修改的内容<br>
提交历史（commit history） 提交代码的历史记录</p>
<h2><a name="t3"></a><a name="t3"></a><a id="_19"></a>主要的几个命令</h2>
<p>git add # 将工作区的修改提交到暂存区<br>
git commit # 将暂存区的修改提交到当前分支<br>
git reset # 回退到某一个版本<br>
git stash # 保存某次修改<br>
git pull # 从远程更新代码<br>
git push # 将本地代码更新到远程分支上<br>
git reflog # 查看历史命令<br>
git status # 查看当前仓库的状态<br>
git diff # 查看修改<br>
git log # 查看提交历史<br>
git revert # 回退某个修改</p>
<h2><a name="t4"></a><a name="t4"></a><a id="git_commit_33"></a>git commit用法</h2>
<blockquote>
<p>git commit –m “本次提交描述”</p>
</blockquote>
<p>该命令会将git add .存入暂存区修改内容提交至本地仓库中，若文件未添加至暂存区，则提交时不会提交任何修改。</p>
<blockquote>
<p>git commit -a</p>
</blockquote>
<p>相当于运行 git add -u把所有当前目录下的文件加入缓存区域再运行git commit.<br>
注意！对于新增的文件，并没有被commit</p>
<blockquote>
<p>git commit –am “本次提交描述”<br>
或者git commit –a –m“本次提交描述”</p>
</blockquote>
<p>等同于上面的-a和-m</p>
<blockquote>
<p>git commit --amend</p>
</blockquote>
<p>修改最近一次提交。有时候如果提交注释书写有误或者漏提文件，可以使用此命令。对于漏提交的文件，需要git add到缓存区之后，git commit --amend才能将修改追加到最近的一次提交上。</p>
<h2><a name="t5"></a><a name="t5"></a><a id="git_stash_55"></a>git stash用法</h2>
<p>$ git stash<br>
所有未提交的修改都保存起来，用于后续恢复当前工作目录</p>
<p>$ git stash save “stash_name”<br>
给每个stash加一个message，用于记录版本</p>
<p>$ git stash pop  /  git stash apply<br>
恢复最新缓存的工作目录（第一个），并删除缓存堆栈中的那一个stash删除(pop), apply则只恢复不删除</p>
<p>$ git stash list<br>
查看现有所有stash<br>
在使用git stash pop(apply)命令时可以通过名字指定使用哪个stash，默认使用最近的stash（即stash@{0}）</p>
<p>$ git stash drop<br>
移除最新的stash，后面也可以跟指定stash的名字</p>
<h2><a name="t6"></a><a name="t6"></a><a id="git_reset_72"></a>git reset用法</h2>
<p>git reset根据–soft –mixed –hard，会对working tree和index和HEAD进行重置</p>
<p>$ git reset HEAD^</p>
<p>回退版本，一个^表示一个版本，可以多个，另外也可以使用 git reset HEAD~n这种形式。<br>
也可以回退到指定版本：<br>
$ git reset commit-id</p>
<blockquote>
<p>soft 参数：git reset --soft HEAD~1 意为将版本库软回退1个版本，所谓软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区</p>
</blockquote>
<blockquote>
<p>默认的mixed参数：git reset HEAD～1 意为将版本库回退1个版本，将本地版本库的头指针全部重置到指定版本，且会重置暂存区，即这次提交之后的所有变更都移动到工作区</p>
</blockquote>
<blockquote>
<p>hard参数：git reset --hard HEAD～1 意为将版本库回退1个版本，但是不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码清空（工作区是clean状态）</p>
</blockquote>
<p>注意，soft参数与默认参数都不会修改工作区代码，只有hard参数才会修改工作区代码。</p>
<p>另外，git reset HEAD filename<br>
回退文件，将文件从暂存区回退到工作区（unstage），此时不能带hard,soft参数</p>
<h2><a name="t7"></a><a name="t7"></a><a id="git_reflog_93"></a>git reflog</h2>
<p>如果在回退以后又想再次回到之前的版本，git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">615ce06 HEAD@{44}: rebase -i (finish): returning to refs/heads/my_test_branch
615ce06 HEAD@{45}: rebase -i (fixup): zancun_new
702356c HEAD@{46}: rebase -i (fixup): # This is a combination of 2 commits.
c997622 HEAD@{47}: rebase -i (reword): zancun_new
fb74ec2 (origin/master, origin/HEAD) HEAD@{48}: rebase -i (start): checkout FETCH_HEAD
f3ef592 HEAD@{49}: commit: zancun3
6b82c75 HEAD@{50}: commit: zancun2
e900fa0 HEAD@{51}: commit: zancun
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre>
<p>比如说，回退到commit: zancun3，只需要：<br>
git reset --hard f3ef592 (或者HEAD@{49})  即可<br>
这个命令对于找回丢失的代码非常有用。</p>
<h2><a name="t8"></a><a name="t8"></a><a id="git_add_110"></a>git add</h2>
<p>删除文件后需要 git add -A, 光 git add. 不行，区别如下：</p>
<p>git add -A 保存所有的修改<br>
git add . 保存新的添加和修改，但是不包括删除<br>
git add -u 保存修改和删除，但是不包括新建文件。<br>
所以默认使用git add -A就行</p>
<h2><a name="t9"></a><a name="t9"></a><a id="git_checkout_119"></a>git checkout</h2>
<p>git checkout既可以操作分支，也可以操作文件</p>
<h3><a name="t10"></a><a name="t10"></a><a id="git_checkout_121"></a>git checkout切换分支</h3>
<p>$ git checkout -b newBranchName<br>
Switched to a new branch ‘newBranchName’</p>
<p>这相当于执行下面这两条命令：<br>
git branch newBranchName<br>
git checkout newBranchName(工作区一定要是clean的)</p>
<p>$ git checkout -b newBranchName remote_branch_name<br>
拉取远程分支remote_branch_name创建一个本地分支newBranchName，并切到本地分支newBranchName，采用此种方法建立的本地分支会和远程分支建立映射关系。</p>
<h3><a name="t11"></a><a name="t11"></a><a id="git_checkout__132"></a>git checkout 回退修改</h3>
<p>git checkout – fileName<br>
这条命令把fileName从当前HEAD中检出，也就是回退当前工作区的这个文件的修改<br>
–可以省略不写</p>
<p>如果需要回退工作区的全部文件修改，可以使用：<br>
git checkout --hard HEAD<br>
而不需要对每个文件进行checkout，这样太累</p>
<h2><a name="t12"></a><a name="t12"></a><a id="git_revert_141"></a>git revert</h2>
<p>git revert,反转提交, 撤销一个提交的同时会创建一个新的提交，也就是用一个新提交来消除一个历史提交所做的任何修改.</p>
<p>git revert commit-id   revert指定的一个commit<br>
git revert HEAD~3  revert指定倒数第四个commit</p>
<p>revert过程有可能遇到冲突，要么git revert --abort终止此次revert操作，代码还原至revert命令前。要么手动消除冲突(同普通的冲突解决)，然后add commit</p>
<h2><a name="t13"></a><a name="t13"></a><a id="resetcheckoutrevert_149"></a>reset,checkout,revert总结</h2>
<p>下面这个表格总结了这些命令最常用的使用场景。记得经常对照这个表格，因为你使用Git时一定会经常用到。<br>
命令  |	作用域 |	常用情景<br>
---- | —<br>
git reset  |	提交层面 |	在私有分支上舍弃一些没有提交的更改<br>
git reset|	文件层面 |	将文件从缓存区中移除<br>
git checkout|	提交层面|	切换分支或查看旧版本<br>
git checkout|	文件层面|	舍弃工作目录中的更改<br>
git revert|	提交层面|	在公共分支上回滚更改<br>
git revert|	文件层面|	（然而并没有）</p>
<h2><a name="t14"></a><a name="t14"></a><a id="_162"></a>删除分支</h2>
<p>删除分支： $ git branch -d branchName<br>
或者，     git branch -D branchName   删除分支（不管它有没有merge）<br>
前提是先要切换到其他分支</p>
<p>$ git branch -d branch1<br>
error: The branch ‘branch1’ is not fully merged.<br>
If you are sure you want to delete it, run ‘git branch -D branch1’.</p>
<h2><a name="t15"></a><a name="t15"></a><a id="git_push_171"></a>git push</h2>
<p>git push命令用于将本地分支的更新，推送到远程主机。</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git push origin master
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建。</p>
<p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git push origin :master
# 等同于
$ git push origin --delete master
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre>
<p>上面命令表示删除origin主机的master分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"> $ git push origin
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>上面命令表示，将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git push
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git push -u origin master
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</p>
<p>将当前分支推送到远程的同名的简单方法，如下:</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git push origin HEAD
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>将当前分支推送到源存储库中的远程引用匹配主机。 这种形式方便推送当前分支，而不考虑其本地名称。如下:</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git push origin HEAD:master
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>单独使用git push时，没有指定push的remote分支名，假如当前本地分支名称与其对应的remote分支名称不一样，则会有一下提示：</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">fatal: The upstream branch of your current branch does not match
the name of your current branch.  To push to the upstream branch
on the remote, use

    git push origin HEAD:my_new_test_branch

To push to the branch of the same name on the remote, use

    git push origin test

To choose either option permanently, see push.default in 'git help config'.
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li></ul></pre>
<p>当执行git push origin test时，会在远程重新创建一个新的分支，名称就是test，然后把修改同步到test分支。</p>
<h2><a name="t16"></a><a name="t16"></a><a id="git_pull_227"></a>git pull</h2>
<p>git pull命令用于从另一个存储库或本地分支获取并集成(整合)。git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>比如，要取回origin主机的master分支，与本地的test分支合并，需要写成下面这样</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git pull origin master:test
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>如果远程分支(master)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写：</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git pull origin master
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>将远程存储库中的更改合并到当前分支中。在默认模式下，git pull是git fetch后跟git merge FETCH_HEAD的缩写。</p>
<p>更准确地说，git pull使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中。 使用–rebase，它运行git rebase而不是git merge。也就是说</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">git pull = git fetch + git merge
git pull --rebase = git fetch + git rebase
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre>
<p>git中都fetch命令是将远程分支的最新内容拉到了本地，但是fetch后是看不到变化的，此时本地多了一个FETCH_HEAD的指针，checkout到该指针后可以查看远程分支的最新内容。然后checkout到master分支，执行metch,选中FETCH_HEAD指针,合并后如果出现冲突则解决冲突，最后commit。</p>
<p>pull的作用就相当于fetch和merge，自动合并</p>
<blockquote>
<p>git fetch origin master<br>
git merge FETCH_HEAD</p>
</blockquote>
<p>git fetch origin isoda-android_1.3.0_feature :branch1<br>
使用远程isoda-android_1.3.0_feature分支在本地创建branch1分支（但不会切换到该分支）</p>
<h3><a name="t17"></a><a name="t17"></a><a id="1_git_merge_260"></a>1. git merge</h3>
<p>将 origin 分支合并到 mywork 分支最简单的办法就是用下面这些命令</p>
<blockquote>
<p>git checkout mywork<br>
git merge origin</p>
</blockquote>
<p>或者，你也可以把它们压缩在一行里:</p>
<blockquote>
<p>git merge origin mywork</p>
</blockquote>
<p>假设远程分支上有3次提交A,B,C:<br>
<img src="http://static.zybuluo.com/Wind729/hd9hb9zrdldthqrv1dq0xvfg/image_1chevldmmedu4f45ur9o6rp3g.png" alt="image_1chevldmmedu4f45ur9o6rp3g.png-13.4kB"></p>
<p>在远程分支origin的基础上创建一个名为"mywork"的本地分支并提交了修改E，同时有其他人在"origin"上做了一些修改并提交了修改D。<br>
<img src="http://static.zybuluo.com/Wind729/b03mwovqa2j4jqjqz1cpitps/image_1chevnkgpshs17133n5bqrfpjt.png" alt="image_1chevnkgpshs17133n5bqrfpjt.png-20.6kB"></p>
<p>用git merge命令把"origin"分支与本地提交合并（merge）成版本M，mywork 分支中新的合并提交（merge-commit）将两个分支的历史连在了一起，但这样会形成图中的菱形，让人很困惑。<br>
<img src="http://static.zybuluo.com/Wind729/dmjwplpbdukx9av9fcpqj28n/image_1chevr3p71knutjj1lv3f4e5391a.png" alt="image_1chevr3p71knutjj1lv3f4e5391a.png-26kB"></p>
<p>Merge 好在它是一个安全的操作，比较安全，现有的分支不会被更改，避免了 rebase 潜在的缺点（后面会说）。另一方面，这同样意味着每次合并上游更改时 feature 分支都会引入一个外来的合并提交。如果 master非常活跃的话，这或多或少会污染你的分支历史。虽然高级的 git log 选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。</p>
<h3><a name="t18"></a><a name="t18"></a><a id="2_git_rebase_280"></a>2. git rebase</h3>
<p>作为 merge 的替代选择，你可以像下面这样将 mywork 分支并入 origin 分支：</p>
<blockquote>
<p>git checkout mywork<br>
git rebase origin</p>
</blockquote>
<p>它会把整个 mywork 分支移动到 origin 分支的后面，有效地把所有 master 分支上新的提交并入过来。但是，rebase为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。rebase的好处是避免了菱形的产生，保持提交曲线为直线，让大家易于理解。<br>
<img src="http://static.zybuluo.com/Wind729/i29227cxdru4gw59186g0qzk/image_1chip8e1b1t1vo01m3t1g2bne91u.png" alt="image_1chip8e1b1t1vo01m3t1g2bne91u.png-26.2kB"></p>
<p>rebase最大的好处是你的项目历史会非常整洁。首先，它不像 git merge 那样引入不必要的合并提交。其次，如上图所示，rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 git log、git reset 和 gitk 来查看项目历史。</p>
<p>不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase 不会有合并提交中附带的信息——你看不到 mywork 分支中并入了上游的哪些更改。</p>
<p>在rebase的过程中，有时也会有conflict，这时Git会停止rebase并让用户去解决冲突，解决完冲突后，用git add命令去更新这些内容，然后不用执行git commit,直接执行git rebase --continue,这样git会继续apply余下的补丁。<br>
在任何时候，都可以用git rebase --abort参数来终止rebase的行动，并且mywork分支会回到rebase开始前的状态。</p>
<p>官方的两张merge和rebase对比图：<br>
merge示例图：<br>
<img src="http://static.zybuluo.com/Wind729/r250wa719d1h9bvwnpiu9uj0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-21%20%E4%B8%8B%E5%8D%8811.01.48.png" alt="屏幕快照 2018-09-21 下午11.01.48.png-126kB"></p>
<p>rebase示例图：<br>
<img src="http://static.zybuluo.com/Wind729/odgnbe1ub59su2zgy5hfpn5m/rebase_wrong.png" alt="rebase_wrong.png-150.4kB"></p>
<h3><a name="t19"></a><a name="t19"></a><a id="3_rebaserebase_304"></a>3. rebase的高级操作–交互式rebase</h3>
<p>交互式的 rebase 允许你更改并入新分支的提交。这比自动的 rebase 更加强大，因为它提供了对分支上提交历史完整的控制。一般来说，这被用于将 feature 分支并入 master 分支之前，清理混乱的历史。</p>
<p>把 -i 传入 git rebase 选项来开始一个交互式的rebase过程：</p>
<blockquote>
<p>git checkout feature<br>
git rebase -i master</p>
</blockquote>
<p>它会打开一个文本编辑器，显示所有将被移动的提交：</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">pick e900fa0 zancun
pick 6b82c75 zancun2
pick f3ef592 zancun3

# Rebase fb74ec2..f3ef592 onto fb74ec2 (3 commands)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like "squash", but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li></ul></pre>
<p>这个列表定义了 rebase 将被执行后分支会是什么样的。更改 pick 命令或者重新排序，这个分支的历史就能如你所愿了。比如说，如果第二个和第三个提交只是修复了第一个提交中的小问题，你可以用 fixup 命令把它们合到第一个提交中，并修改第一个的日志：</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">r e900fa0 zancun
f 6b82c75 zancun2
f f3ef592 zancun3
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre>
<p>这样三个提交合并成了一个提交，并可以重新修改提交日志，非常实用。<br>
忽略不重要的提交会让你的 feature 分支的历史更清晰易读。这是 git merge 做不到的。</p>
<h3><a name="t20"></a><a name="t20"></a><a id="4_Rebase_345"></a>4. Rebase的黄金法则</h3>
<p>当你理解rebase是什么的时候，最重要的就是什么时候不能用rebase。git rebase 的黄金法则便是，绝不要在公共的分支上使用它。</p>
<p>比如说，如果你把 master分支rebase到你的feature 分支上会发生什么：<br>
<img src="http://static.zybuluo.com/Wind729/4plwewr1a1ugdlj2ncipe6ln/rebase_wrong.png" alt="rebase_wrong.png-150.4kB"></p>
<p>这次 rebase 将 master 分支上的所有提交都移到了 feature 分支后面。问题是它只发生在你的代码仓库中，其他所有的开发者还在原来的 master 上工作。因为 rebase 引起了新的提交，Git 会认为你的 master 分支和其他人的 master 已经分叉了。</p>
<p>同步两个 master 分支的唯一办法是把它们 merge 到一起，导致一个额外的合并提交和两堆包含同样更改的提交。不用说，这会让人非常困惑。</p>
<p>所以，在你运行 git rebase 之前，一定要问问你自己「有没有别人正在这个分支上工作？」。如果答案是肯定的，那么把你的爪子放回去，重新找到一个无害的方式（如 git merge）来提交你的更改。不然的话，你可以随心所欲地重写历史。</p>
<h3><a name="t21"></a><a name="t21"></a><a id="5_rebae_357"></a>5. rebae的本地清理功能</h3>
<p>在你工作流中使用 rebase 最好的用法之一就是清理本地正在开发的分支。隔一段时间执行一次交互式 rebase，你可以保证你 feature 分支中的每一个提交都是专注和有意义的。</p>
<p>调用 git rebase 的时候，你有两个基（base）可以选择：上游分支（比如 master）或者你 feature 分支中早先的一个提交。我们在「交互式 rebase」一节看到了第一种的例子。后一种在当你只需要修改最新几次提交时也很有用。比如说，下面的命令对最新的 3 次提交进行了交互式 rebase：</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">git checkout feature
git rebase -i HEAD~3(或者第四个commit-id)
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre>
<p>这样，就可以对本地提交历史中最新的三个提交进行重新整理了，包括提交合并，提交日志修改等等。</p>
<p>通过指定 HEAD~3 作为新的基提交，你实际上没有移动分支——你只是将之后的 3 次提交重写了。注意它不会把上游分支（master）的更改并入到 feature 分支中。</p>
<p>交互式 rebase 是在你工作流中引入 git rebase 的的好办法，因为它只影响本地分支。其他开发者只能看到你已经完成的结果，那就是一个非常整洁、易于追踪的分支历史。</p>
<h2><a name="t22"></a><a name="t22"></a><a id="_371"></a>追踪关系</h2>
<p>建立test仓库 并建立追踪关系</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git branck --track test origin/master
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>修改追踪关系<br>
先切换到test</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git checkout test
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>修改追踪仓库（一定要先切换）</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git branch --set-upstream-to  origin/master
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<p>建立追踪关系之后，本地分支名称和远程一样时，使用git push时不用带上远程名称，git pull也不用带上远程分支名</p>
<h2><a name="t23"></a><a name="t23"></a><a id="git_386"></a>git冲突的修复</h2>
<h3><a name="t24"></a><a name="t24"></a><a id="1__387"></a>1. 直接编辑冲突文件</h3>
<p>使用git pull --rebase经常会出现冲突<br>
冲突产生后，文件系统中冲突了的文件里面的内容会显示为类似下面这样：</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 * test2
 * test3
=======
 * this is my modify, my be conflicked
 * test1000
&gt;&gt;&gt;&gt;&gt;&gt;&gt; my_modify
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre>
<p>其中：&lt;&lt;&lt;&lt;&lt;&lt;&lt;（7个&lt;）HEAD与=<mark><mark><mark>之间的内容是remote上的修改，冲突标记</mark></mark></mark>=与&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的内容是我的修改内容。<br>
在这两者之间选择任何你需要的内容保留下来，并删除所有的===,&lt;&lt;&lt;,&gt;&gt;&gt;即可解决冲突，解决完成之后，git add -A, git rebase --continue就提交了代码</p>
<h3><a name="t25"></a><a name="t25"></a><a id="2__402"></a>2. 利用图形界面工具解决冲突</h3>
<p>当然我们也可以利用图形工具解决冲突<br>
如果要解决的冲突很多，且比较复杂，图形界面的冲突解决工具就显得很重要了。<br>
执行git mergetool用预先配置的Meld(Beyond Compare)解决冲突：<br>
<img src="http://static.zybuluo.com/Wind729/07eyy9vzxuuo6zetapxxqev6/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-06%20%E4%B8%8B%E5%8D%882.43.55.png" alt="屏幕快照 2018-07-06 下午2.43.55.png-630.8kB"></p>
<p>上面左右两个窗口依次是“LOCAL”、“REMOTE”，它们只是提供解决冲突需要的信息，是无法编辑的。中间的窗口是合并后的结果，可以手动修改，也可以点击相应颜色的箭头选择“LOCAL”或者“REMOTE”。</p>
<p>如果不向解决冲突，回到之前状态，可执行：</p>
<pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">$ git rebase --abort
<div class="hljs-button {2}" data-title="复制" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.4259&quot;}"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre>
<h3><a name="t26"></a><a name="t26"></a><a id="3__415"></a>3. 代码提交完整流程</h3>
<p>步骤如下：<br>
git add -A<br>
git commit -m “message”<br>
git pull --rebase  (或者git fetch + git rebase）<br>
解决冲突<br>
git add 冲突文件<br>
git rebase –continue<br>
git push<br>
其中，3、4、5点，如果没遇到冲突就不用进行，直接push上去。<br>
当遇到冲突时，git会提示patch failed，并要我们解决问题了再执行git rebase --continue</p>
<h2><a name="t27"></a><a name="t27"></a><a id="_429"></a>常用命令速查表</h2>
<p><img src="http://static.zybuluo.com/Wind729/yztg75sj5y28j9d7vmqhlsni/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-21%20%E4%B8%8B%E5%8D%8811.05.05.png" alt="屏幕快照 2018-09-21 下午11.05.05.png-4548kB"></p>

                                    </div><div data-report-view="{&quot;mod&quot;:&quot;1585297308_001&quot;,&quot;dest&quot;:&quot;https://blog.csdn.net/weelyy/article/details/82823798&quot;,&quot;extend1&quot;:&quot;pc&quot;,&quot;ab&quot;:&quot;new&quot;}"><div></div></div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e0530931f4.css" rel="stylesheet">
                                </div>
            </article>
</div>